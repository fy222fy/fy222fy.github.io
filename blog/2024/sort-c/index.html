<!DOCTYPE html> <html lang="en-us"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++实现不同的排序算法，以及实现过程中的难点 | Haonan Feng </title> <meta name="author" content="Haonan Feng"> <meta name="description" content="this is what included tabs in a post could look like"> <meta name="keywords" content="AI Security &amp; Formal Verification"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png?2b8ae22354b0523281291bc7c947047f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://fy222fy.github.io/blog/2024/sort-c/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Haonan</span> Feng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/news/">news </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="nav-item active"> <a class="nav-link" href="/zh-cn/blog/2024/sort-c/"> ZH-CN</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++实现不同的排序算法，以及实现过程中的难点</h1> <p class="post-meta"> Created in May 01, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/formatting"> <i class="fa-solid fa-hashtag fa-sm"></i> formatting</a>   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>   ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>为了查找方便，产生了各种各样地排序算法，根据不同的使用场景，有不同类型的排序方式，如插入排序、交换排序、选择排序、归并排序、基数排序等。 很多人明白不同排序的运作原理，但是并没有自己实现过，这篇文章将分析几种排序方式的原理，并介绍利用c++实现算法过程中用到的小技巧。</p> <p>首先，所有的排序方式如下面的目录所示，一个简单的比较如下表。</p> <table> <tr> <th colspan="3" rowspan="2">排序方式</th> <th colspan="3">时间复杂度</th> <th rowspan="2">空间<br>复杂度</th> <th rowspan="2">稳定性<br> </th> <th rowspan="2">初始状态影响</th> <th rowspan="2">适用情况<br> </th> <th rowspan="2">适用规模</th> <th colspan="2">比较次数</th> <th rowspan="2">移动次数<br> </th> </tr> <tr> <td>最好<br> </td> <td>平均</td> <td>最坏</td> <td>最小<br> </td> <td>最大</td> </tr> <tr> <td rowspan="11">内<br>部<br>排<br>序</td> <td rowspan="3">插<br>入<br>排<br>序</td> <td>直接插入排序</td> <td>n</td> <td colspan="2">n<sup>2</sup> </td> <td>1</td> <td>是<br> </td> <td>越有序越好</td> <td>顺序表<br>链表<br> </td> <td>&lt;10000<br> </td> <td>n-1<br> </td> <td>n(n-1)/2&lt;/sup&gt;</td> <td>0~n(n-1)/2</td> </tr> <tr> <td>折半插入排序</td> <td>n</td> <td colspan="2">n<sup>2</sup> </td> <td>1</td> <td>是</td> <td>越有序越好</td> <td>顺序表</td> <td>&lt;10000<br> </td> <td>log<sub>2</sub>n+1</td> <td>n<sup>2</sup> </td> <td>0~n-1</td> </tr> <tr> <td>希尔排序</td> <td>n<sup>1.3</sup> </td> <td colspan="2">n<sup>2</sup> </td> <td>1</td> <td>否<br> </td> <td>越有序越好</td> <td>顺序表</td> <td>&lt;1000<br> </td> <td colspan="2">&lt;n<sup>2</sup> </td> <td>小于直插</td> </tr> <tr> <td rowspan="2">交<br>换<br>排<br>序</td> <td>冒泡排序</td> <td>n</td> <td colspan="2">n<sup>2</sup> </td> <td>1</td> <td>是</td> <td>越有序越好</td> <td>顺序表</td> <td>&lt;10000<br> </td> <td colspan="2">n(n-1)/2</td> <td>0~n(n-1)/2</td> </tr> <tr> <td>快速排序</td> <td colspan="2">nlog<sub>2</sub>n</td> <td>n<sup>2</sup> </td> <td>log<sub>2</sub>n</td> <td>否</td> <td>有序反而慢</td> <td>顺序表</td> <td>n很大</td> <td>nlog<sub>2</sub>n</td> <td>n(n-1)/2</td> <td></td> </tr> <tr> <td rowspan="2">选<br>择<br>排<br>序</td> <td>简单选择排序</td> <td colspan="3">n<sup>2</sup> </td> <td>1</td> <td>否</td> <td>比较次数无关<br>移动次数有关</td> <td></td> <td>&lt;10000<br> </td> <td>n<sup>2</sup><br> </td> <td>n<sup>2</sup> </td> <td>n</td> </tr> <tr> <td>堆排序</td> <td colspan="3">nlog<sub>2</sub>n</td> <td>1</td> <td>否</td> <td>有关<br>但不怕坏情况</td> <td>顺序表</td> <td>n很大</td> <td colspan="2">nlog<sub>2</sub>n</td> <td></td> </tr> <tr> <td rowspan="3">分<br>配<br>式<br>排<br>序</td> <td>桶排序</td> <td colspan="3">n+k</td> <td>n+k</td> <td>是</td> <td>基本无关</td> <td>含关键字</td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>计数排序<br> </td> <td colspan="3">n+max-min</td> <td>max-min</td> <td>是</td> <td>最大最小值<br>差距越小越好</td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>基数排序<br> </td> <td colspan="3">nd</td> <td>n+k</td> <td>是</td> <td>只能非<br>负整数排序<br>最大最小值<br>差距越小越好</td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td colspan="2">归并排序</td> <td colspan="3">nlog<sub>2</sub>n</td> <td>1</td> <td>是</td> <td>无关</td> <td>顺序表<br>链表<br> </td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td rowspan="2">外<br>部<br>排<br>序</td> <td colspan="2">多路归并排序</td> <td colspan="3">nlog2n</td> <td>n</td> <td>是<br> </td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td colspan="2">置换-选择排序</td> <td colspan="3">d(n+r)</td> <td>r</td> <td>是<br> </td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> </table> <p>@[toc]</p> <h2 id="内部排序">内部排序</h2> <h3 id="插入排序insert-sort">插入排序(Insert Sort)</h3> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>基本思想</strong> </li> </ul> <p>插入排序的思想是一次拿一个元素出来，放在前面已经排好顺序的序列中。 类似于扑克牌整牌的过程。 在这个过程中，每一次都有一个元素会落到最终的位置。</p> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>排序过程</strong> </li> </ul> <p>排序过程主要分为三步。 第一步，在待排序列（也就是后面的序列）中提取出第一个元素。 第二步，在已排的有序序列（前面排好的序列）中查找这个元素应该在的位置。 第三步，将该元素插入到它应该在的位置。</p> <p>在第二步查找的过程中，如果使用<em>顺序查找</em>，那么就是直接插入排序，如果使用折半查找，那么就是折半插入排序。 另外，如果抽取出部分序列进行排序，最后再综合排序，那么就是希尔排序。</p> <h4 id="直接插入排序">直接插入排序</h4> <ul> <li> <strong>过程</strong>：</li> </ul> <ol> <li>在待排序列中提取第一个元素；</li> <li>用顺序查找的方法查找该元素在前边已排序列的位置；</li> <li>插入该元素。</li> </ol> <ul> <li> <strong>适用范围</strong>：顺序表，链表都可以，但链表使用该方法是一大优势，因为插入元素比较简单,不需要移动后续的所有元素。另外，越有序的序列排序速度越快。</li> <li> <p><strong>性能</strong>：直接插入排序要对每个元素进行比较和插入，n个元素，当全部都排序好时，每个元素只需要比较一次，所以最好时间复杂度是o(1)。在最坏和平均情况时每个元素比较的次数大约是n次，所以<strong>时间复杂度o(n<sup>2</sup>)</strong>，因为没有用到额外的存储空间，所以<strong>空间复杂度o(1)</strong>。</p> </li> <li> <strong>稳定性</strong>：稳定，但写代码的时候注意插入的时候遇到相同的数据，要插入到已排序列该数据元素之后，这样才能保证稳定性。</li> <li> <strong>比较次数</strong>：当序列本身有序的时候，比较的次数是最小的，因为每个元素只需要与其前一个元素（也就是已排元素的最后一个元素）作比较，然后发现它已经比这个元素大，所以只需要比较n-1次。但在最坏情况下，每个元素都要和前面的所有已排元素比较一遍也就是1+2+…+n-1 = n(n-1)/2次。</li> <li> <p><strong>移动次数</strong>：最好情况下，就根本不需要移动。在最坏情况下，每个元素都要使之前的已排元素全部后移一次，也是n(n-1)/2次。</p> </li> <li> <strong>代码实现</strong>：首先对整个序列进行遍历，也就是第一步的待排序列取元素。 按照顺序，应该是通过顺序查找的方式找到待插入位置的下标，然后再顺序后移元素，将取出的元素插入到空出的位置。</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void DirectInsertSort1(vector&lt;int&gt; &amp;nums) {
	//默认第一个元素就是一个已排序列，从第二个元素开始向后循环
	int n = nums.size();
	for (int i = 1; i &lt; n; ++i) {//从第二个元素开始遍历待排序列
		int i2 = 0;
		//查找nums[i]元素应该在前面已排元素的哪个位置
		//因为是查找过程，所以可以直接把i这个元素当成哨兵，减少判断界限的语句
		while (nums[i2] &lt; nums[i]) {
			i2++;
		}
		//找到位置以后，从i这个位置依次后移元素
		int temp = nums[i];
		for (int i3 = i; i3 &gt; i2; --i3) {//移动元素的过程
			nums[i3] = nums[i3 - 1];//后移
		}
		//最后把i这个元素放在前面已排序列中应有的位置
		nums[i2] = temp;
	}
}
</code></pre></div></div> <p>上述代码符合直接插入排序的概念，易于理解，但是实际上，查找和插入的过程上没有必要分开，从前往后的查找过程可以改成从提取元素的位置向前查找，并且在查找的过程中就可以移动了。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void DirectInsertSort2(vector&lt;int&gt;&amp; nums) {
	int temp = 0;
	//默认第一个元素就是一个已排序列，从第二个元素开始向后循环
	int n = nums.size();
	for (int i = 1; i &lt; n; ++i) {
		int temp = nums[i];
		int i2 = i - 1;
		for (; i2 &gt;= 0; --i2) {
			//直接从该元素向前查找（因为该元素之前就是已排序列）
			if (nums[i2] &gt; temp) {//只要没找到位置就将元素向后移动
				nums[i2 + 1] = nums[i2];
			}
			else {//找到应有的位置，后面的元素也后移完了
				nums[i2 + 1] = temp;//刚好插入
				break;
			}
		}
		if (i2 &lt; 0) {//如果一直找到头了还没有找到位置，那么就放在最开始
			nums[0] = temp;
		}
	}
}
</code></pre></div></div> <p>更简单地，也可以直接在查找的过程中进行交换，这样就不需要设置一个temp来进行保存了，当查找结束的时候，交换也结束，元素也被交换到了应有的位置。 不过实际上这种方式看起来简单，但会降低算法的性能，交换一个元素至少要三个操作，而多次交换其实都用的是这同一个元素，所以不如上一种算法来的快。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void DirectInsertSort3(vector&lt;int&gt;&amp; nums) {//优化版本
	int temp = 0;
	//默认第一个元素就是一个已排序列，从第二个元素开始向后循环
	int n = nums.size();
	for (int i = 1; i &lt; n; ++i) {
		int temp = nums[i];
		for (int i2 = i - 1; i2 &gt;= 0; --i2) {//向前边查找边交换
			if (nums[i2] &gt; nums[i2 + 1]) {//没找到位置，就交换
				swap(nums[i2], nums[i2 + 1]);
			}
			else {
				break;
			}
		}
	}
}
</code></pre></div></div> <h4 id="折半插入排序binary-insert-sort">折半插入排序(Binary Insert Sort)</h4> <ul> <li> <strong>过程</strong>：</li> </ul> <ol> <li>在待排序列中提取第一个元素；</li> <li>用折半查找的方法查找该元素在前边已排序列的位置；</li> <li>插入该元素。</li> </ol> <ul> <li> <p><strong>适用范围</strong>：只能顺序表，链表不行因为折半查找需要跳跃，链表无法跳跃查找。另外，越有序的序列排序速度越快。</p> </li> <li> <p><strong>性能</strong>：虽然折半查找的时间复杂度为log<sub>2</sub>n，但是即便快速查找到了插入位置，后面的元素还是需要依次后移，所以<strong>时间复杂度o(n<sup>2</sup>)</strong>，<strong>空间复杂度o(1)</strong></p> </li> <li> <strong>稳定性</strong>：稳定</li> <li> <strong>比较次数</strong>：当序列本身有序的时候，比较的次数是最小的，因为每个元素只需要与其前一个元素（也就是已排元素的最后一个元素）作比较，然后发现它已经比这个元素大，所以只需要比较n-1次。但在最坏情况下，每个元素通过折半查找要和前面的元素比较log<sub>2</sub>k次，k是已排序列的个数，所以总共需要比较的次数是log<sub>2</sub>1+log<sub>2</sub>2+…+log<sub>2</sub>n-1 ≈ log<sub>2</sub>(n!) ≈ nlog<sub>2</sub>n (log<sub>2</sub>(n!)和nlog<sub>2</sub>n是同阶函数)</li> <li> <strong>移动次数</strong>：最好情况下，就根本不需要移动。在最坏情况下，每个元素都要使之前的已排元素全部后移一次，也是n(n-1)/2次。</li> <li> <strong>代码实现</strong>：与直接插入排序的唯一区别就是查找用的是折半查找。</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void BinaryInsertSort(vector&lt;int&gt; &amp;nums){
	//默认第一个元素就是一个已排序列，从第二个元素开始向后循环
	int n = nums.size();
	for (int i = 1; i &lt; n; i++) {//从第二个元素向后遍历
		int low = 0;
		int high = i - 1;
		int mid = (low + high) / 2;
		int target = nums[i];
		while (low &lt;= high) {
			if (nums[mid] &gt; target) {
				high = mid-1;
				mid = low + (high - low) / 2;
			}
			else {
				low = mid+1;
				mid = low + (high - low) / 2;
			}
		}
		//折半查找后，调整一下mid的位置
		if (nums[mid] &lt; target) {
			mid++;
		}
		//最后从i这个位置，向后移动元素，为目标元素空出位置
		for (int i2 = i; i2 &gt; mid; --i2) {
			nums[i2] = nums[i2 - 1];
		}
		nums[mid] = target;
	}
}
</code></pre></div></div> <h4 id="希尔排序">希尔排序</h4> <ul> <li> <strong>过程</strong>： 以排序一个20个元素的序列为例</li> </ul> <ol> <li>选取一系列缩小增量序列，选取规则随意，一般是对半选取，如{10,5,2,1}，直到缩小到1。</li> <li>对第一个缩小增量10，选取(1)，(11)两个元素，使用直接插入排序，然后再选取(2)，(12)两个元素，使用直接插入排序….直到选取(10)，(20)两个元素，使用直接插入排序。</li> <li>对第二个缩小增量5，选取(1),(6),(11),(16)四个元素，使用直接插入排序，然后再选取(2),(7),(12),(17)四个元素，使用直接插入排序….直到选取(5),(10),(15),(20)四个元素，使用直接插入排序。</li> <li>继续缩小增量，直到增量为1，选取(1)~(20)这20个元素，使用直接插入排序，这时候序列本身已经基本有序，所以很快就排列完成了。</li> </ol> <p>注意：增量序列的选取是任意的，不一定非要对半选取。</p> <ul> <li> <p><strong>适用范围</strong>：只能顺序表，链表不行因为无法跳跃查找。希尔排序也是越有序越好。</p> </li> <li> <p><strong>性能</strong>：<strong>时间复杂度o(n<sup>1.3</sup>)~o(n<sup>2</sup>)</strong>，希尔排序时间复杂度的下限是nlog<sub>2</sub>n，没有快速排序快，但快速排序在数据已经有序的时候，会变得非常慢，所以可以建议在任何情况下先使用希尔排序进行排序。由于没有用到额外辅助空间，所<strong>空间复杂度o(1)</strong>。希尔排序之所以比直接插入排序快，是因为通过大增量的排序，一个元素已经大致移动到了它最终该在的位置上了，所以它总体上不需要像直接插入排序那样移动那么多次。</p> </li> <li> <p><strong>稳定性</strong>：稳定</p> </li> <li> <p><strong>代码实现</strong>：</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void ShellSort(vector&lt;int&gt; &amp;nums) {
	int n = nums.size();
	vector&lt;int&gt; temp;
	for (int gap = n / 2; gap &gt; 0; gap /= 2) {//对每一种增量进行排序
		for (int i = 0; i &lt; gap; i++) {//对该种增量下的全部子序列进行排序
			for (int ii = i + gap; ii &lt; n; ii += gap) {//对该子序列进行直插排序
				//以下是直接插入排序的过程
				int temp = nums[ii];
				int i2 = ii - gap;
				for (; i2 &gt;= i; i2 -= gap) {
					if (nums[i2] &gt; temp) {
						nums[i2 + gap] = nums[i2];
					}
					else {
						nums[i2 + gap] = temp;
						break;
					}
				}
				if (i2 &lt; 0) {
					nums[i] = temp;
				}
			}
		}
	}
</code></pre></div></div> <h3 id="交换排序swap-sort">交换排序(Swap Sort)</h3> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>基本思想</strong> </li> </ul> <p>交换排序的基本思想是相邻的元素两两之间进行比较，然后根据大小关系进行交换，使得元素逐渐有序。</p> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>特征</strong>：每次都会有一个元素到达最终位置。</li> </ul> <h4 id="冒泡排序bubble-sort">冒泡排序(Bubble Sort)</h4> <ul> <li> <p><strong>过程</strong>： 以从从头到尾，两两元素之间进行比较，并根据大小进行交换，在一趟冒泡排序后，最大的元素就冒到最后面去了，然后剩下的元素再次进行，一直冒泡n次，就有序了。</p> </li> <li> <p><strong>适用范围</strong>：顺序表，链表。</p> </li> <li> <p><strong>稳定性</strong>：稳定。</p> </li> <li> <p><strong>性能</strong>：在最好的情况下，已经有序，时间复杂度o(n)，平均和最坏的<strong>时间复杂度都是o(n<sup>2</sup>)</strong>，<strong>空间复杂度o(1)</strong>。</p> </li> <li> <strong>稳定性</strong>：稳定</li> <li> <strong>比较次数</strong>：冒泡排序总要搞那么n-1轮，所以比较次数一定是n(n-1)/2,。</li> <li> <strong>移动次数</strong>：当已经有序的情况下，冒泡排序不需要移动元素，当初始状态是反序时，冒泡排序每一趟要将元素从起始位置移动到该趟的最后边，n-1趟中，每一趟移动的次数分别是n-1，n-1…..,1，所以最多移动的次数是n(n-1)/2。</li> <li> <strong>代码实现</strong>：</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void BubbleSort(vector&lt;int&gt; &amp;nums) {
	for (int n = nums.size(); n &gt; 1; n--) {//遍历未排序的序列
		for (int i = 0; i + 1 &lt; n; i++) {//遍历每两个相邻的元素
			if (nums[i] &gt; nums[i + 1]) {//比较并交换
				swap(nums[i], nums[i + 1]);
			}
		}
	}
}
</code></pre></div></div> <h4 id="快速排序quick-sort">快速排序(Quick Sort)</h4> <ul> <li> <strong>过程</strong>： 基于分治法的原则，递归地求解问题。</li> </ul> <ol> <li>随意选取一个元素（可以是首元素也可以是尾元素也可以是随机一个元素），然后将它放在头部或者尾部。放在头部是左基准快排，放在末尾是右基准快排。</li> <li>通过交换的方式（具体2种方法见代码实现），将该基准元素放在其最终排序的位置，即左边的元素均小于它，右边的元素均大于它。</li> <li>递归地将左右两边的子序列快速排序。</li> </ol> <ul> <li> <p><strong>适用范围</strong>：顺序表，链表，其中的数据最好较为随机，有序反而排序可能变慢。</p> </li> <li> <p><strong>性能</strong>：在最好的情况下，<strong>时间复杂度o(nlog<sub>2</sub>n)</strong>，平均下来也是o(nlog<sub>2</sub>n)，最坏的时间复杂度都是o(n<sup>2</sup>)，<strong>空间复杂度o(log<sub>2</sub>n)~oo(n)</strong>。</p> </li> </ul> <p><strong>问：如何计算快速排序的时间复杂度？</strong></p> <ol> <li>递归分析法</li> </ol> <p>首先分析最坏情况，当序列本身已经有序，那么n个元素，分成两个部分，一个部分的长度为n-1，另一个部分长度为0。这样就需要递归n次。在第一次，需要把基准元素比较n-1次，第二次递归，需要比较n-2次….最后需要比较1次，所以总共执行的比较次数是n(b-1)/2次，时间复杂度是o(n)。</p> <p>在正常情况下，n个元素，分成两个部分递归，一个部分长a，另一个部分长b，有a+b=n-1的关系。其中，a序列需要执行的比较次数为a，b序列需要执行的比较次数为b，所以这一层递归需要执行的比较次数是n-1，同理，下一层的4个递归序列总共加起来要执行的比较次数为n-2。按照递归树，n个元素的递归树，其高度为log<sub>2</sub>(n+1)，而根据上面的分析，每一层需要执行的比较次数已经确定，所以总共需要执行的比较次数大约为nlog<sub>2</sub>n，这既是算法的最差时间复杂度，也是算法的平均复杂度。</p> <ol> <li>主定理法</li> </ol> <p>假设有递推关系式T(n)=aT(n/b)+f(n)，其中为n问题规模，a为递推的子问题数量，n/b为每个子问题的规模（假设每个子问题的规模基本一样），f(n)为递推以外进行的计算工作。</p> <p>(1) 若f(n)=o(n<sup>log<sub>b</sub>a-ε</sup>),ε&gt;0，那么T(n)=o(n<sup>log<sub>b</sub>a</sup>)。</p> <p>(2) 若f(n)=o(n<sup>log<sub>b</sub>a</sup>)，那么T(n)=o(n<sup>log<sub>b</sub>a</sup>logn)。</p> <p>(3) 若f(n)=o(n<sup>log<sub>b</sub>a+ε</sup>),ε&gt;0，且对于某个常数c&lt;1和所有充分大的n有af(n/b)≤cf(n),那么那么T(n)=o(f(n))。</p> <p>在快速排序中，a = 2, b = 2, f(n) = o(n)，所以f(n)满足第二种情况，所以直接根据主定理，可以判断其算法的时间复杂度为o(nlog<sub>2</sub>n)</p> <p><strong>问：如何计算快速排序的空间复杂度？</strong></p> <p>递归算法的空间复杂度=递归调用的深度×每次递归调用的额外空间</p> <p>在最坏情况下，递归树的深度为n，每个递归实例并没有额外的空间使用，所以最差空间复杂度为o(n)。</p> <p>在正常情况下，递归树的深度为log<sub>2</sub>n，无额外空间使用，所以空间复杂度为o(log<sub>2</sub>n)。</p> <ul> <li> <strong>稳定性</strong>：不稳定</li> <li> <strong>比较次数</strong>：在最坏的情况下，已经有序，退化为冒泡排序算法，第一个元素需要比较n-1次，第二个元素需要比较n-2次，总共需要比较最多n(n-1)/2次。在一般情况下，根据时间复杂度计算，总共需要比较nlog<sub>2</sub>n次。</li> <li> <strong>代码实现</strong>：</li> </ul> <p>第一种方法，从序列最开始进行遍历，每当遇到一个比基准元素小的元素，就把它扔到前面去，遍历结束后，所有比他小的都扔在了前面，剩下的就是比它大的，然后把基准元素放在中间。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void QuickSort(vector&lt;int&gt;&amp; nums) {
	QuickRecursion2(nums, 0, nums.size()-1);
}
void QuickRecursion(vector&lt;int&gt;&amp; nums, int low, int high) {
	if (low &gt;= high) {//结束循环的标志是待排子序列已经长度为1
		return;
	}
	//右基准快排
	//（实际上可以随机一个元素并放在右边作为基准，防止待排序列本身有序）
	int key = nums[high];
	int mid = low;//找到基准元素的最终位置mid，保证左小于它，右大于它
	for (int i = low; i &lt;= high; i++) {
		if (nums[i] &lt; key) {//每当遇到一个比基准元素小的数字
			swap(nums[mid], nums[i]);//就把它和mid交换，并++mid
			mid++;
		}
	}
	//找到最终位置后，将它和基准元素high交换
	swap(nums[mid], nums[high]);
	//递归地解决左序列和右序列的排序问题
	QuickRecursion(nums, low, mid - 1);
	QuickRecursion(nums, mid + 1, high);
}
</code></pre></div></div> <p>第二种方法，设置一个low指针一个high指针，low指针从前向后，找到一个比基准元素大的数字，与high指针对换，然后high指针从后向前，找到一个比基准元素小的数字，与low指针对换，直到low=high，就找到了该基准元素的位置。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void QuickSort(vector&lt;int&gt;&amp; nums) {
	QuickRecursion2(nums, 0, nums.size()-1);
}
void QuickRecursion2(vector&lt;int&gt;&amp; nums, int low, int high) {
	if (low &gt;= high) {//结束循环的标志是待排子序列已经长度为1
		return;
	}
	//右基准快排
	//以最右边的数作为基准
	int key = nums[high];
	int l = low;
	int h = high;
	while (l != h) {//寻找mid的位置
		//low从前向后，找到比key大的，就和high作交换
		for (; l != h; l++) {
			if (nums[l] &gt; key) {
				swap(nums[l], nums[h]);
				break;
			}
		}
		//high从前向后，找到比key小的，就和low作交换
		for (; h!=l; h--) {
			if (nums[h] &lt; key) {
				swap(nums[h], nums[l]);
				break;
			}
		}
	}
	//交换结束后，l和h的位置都指向mid，并且基准元素也被交换到了这个位置
	int mid = l;
	QuickRecursion2(nums, low, mid - 1);
	QuickRecursion2(nums, mid + 1, high);
}
</code></pre></div></div> <h3 id="选择排序">选择排序</h3> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>基本思想</strong> </li> </ul> <p>从所有元素中选择一个最小的，放在第一位，然后再选、再选、再选。</p> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled><strong>特征</strong>：每次都会有一个元素到达最终位置。</li> </ul> <h4 id="简单选择排序">简单选择排序</h4> <ul> <li> <strong>过程</strong>：从未排序的序列中找出最小的，和头交换，然后去掉头，再继续找。</li> </ul> <p>-<strong>适用范围</strong>：顺序表，链表。</p> <ul> <li> <strong>性能</strong>：<strong>时间复杂度o(n<sup>2</sup>)</strong> = 比较次数o(n<sup>2</sup>)+移动次数o(n)，不论初始状态如何都要比较n<sup>2</sup>次，但是移动的次数不一定。 <strong>空间复杂度o(1)</strong>。</li> <li> <strong>稳定性</strong>：不稳定。</li> <li> <strong>比较次数</strong>：每一个元素都需要比较n<sup>2</sup>次才能选择出来，所以比较次数永远是n<sup>2</sup>次。</li> <li> <p><strong>移动次数</strong>：每次选出来一个元素以后，只需要移动一次即可，所以总共的移动次数是n。</p> </li> <li> <strong>代码实现</strong>：</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void SelectionSort(vector&lt;int&gt;&amp; nums) {
	int n = nums.size();
	int temp = INT_MAX;//保存最小的元素
	int index = 0;
	for (int i = 0; i &lt; n; i++) {//遍历整个序列
		for (int i2 = i; i2 &lt; n; i2++) {//
			if (nums[i2] &lt; temp) {//找到最小的元素
				temp = nums[i2];
				index = i2;
			}
		}
		swap(nums[i], nums[index]);//与当前的头元素交换
		temp = INT_MAX;
	}
}
</code></pre></div></div> <h4 id="堆排序">堆排序</h4> <ul> <li> <strong>过程</strong>：</li> </ul> <ol> <li>把序列看成是一个完全二叉树（注意只是看成，不是转换，实际上序列还是顺序存储结构）。</li> <li>通过筛选方式将这个树化为<strong>大根堆</strong>（所有非叶子结点的值大于或等于其子节点的值）。筛选的方法是从i=n/2-1（n为元素个数）这个点开始，比较其与其孩子的关系，并作交换，然后再比i-1，一直比到第一个节点，每一次比较都要让整个树满足定义，即每一个节点都满足比其孩子大的性质。</li> <li>输出顶端最大元素（输出的方式是将其与末尾元素替换，末尾元素时最大元素，下一次不参与建堆）。</li> <li>从头结点（刚刚缓过来的末尾元素）开始再一次构建大根堆。</li> <li>输出-构建直到所有的元素都已经输出，这时正好排序成为了升序序列。</li> </ol> <ul> <li> <p><strong>适用范围</strong>：顺序表。和初始状态基本无关，堆排序的最大好处，就是不怕任何坏情况，所有情况都能在nlog<sub>2</sub>n的时间内完成。</p> </li> <li> <p><strong>性能</strong>：<strong>时间复杂度o(nlog<sub>2</sub>n)</strong>， <strong>空间复杂度o(1)</strong>。</p> </li> </ul> <p>问：堆排序的时间复杂度如何计算？</p> <p>堆排序需要使用到递归，总共有两个过程会影响到时间复杂度。第一个过程是初始化建堆的过程，第二个阶段是不断输出堆顶元素，调整剩余堆的过程。</p> <p>在第一阶段，我们从n/2-1这个非叶子结点开始，比较其与孩子的大小关系（这作为一个基本操作），然后一直比到第一个根节点，总共要比n/2-1个节点。每个节点比较的次数，取决于其所在的层次。例如，倒数第二层的非叶子结点，只比较其与下一层的关系；倒数第三层的非叶子结点，在比较与其孩子关系时，如果发生交换，那么还要递归地保证其子树也是符合大根堆定义的，所以其孩子也要比较一次，直到最后一层，所以要比较2次。可见，假设树的高度是h，那么第i层的元素，最多都要比较h-i次。</p> <p>对于一个n个元素的序列，把它看成树，其树的高度为h=log<sub>2</sub>n，拿第i层来分析，第i层一共有2<sup>i-1</sup>个节点，每个节点要比较h-i次，所以该层总共要比较的次数是</p> <pre><code class="language-math">a_i = 2^{i-1}(h-i) = h2^{i-1}-i2^{i-1}
</code></pre> <p>总共需要比较的层数是从1~h-1（因为h-1是倒数第二层）。也就是说要求a<sub>i</sub>的前h-1项和</p> <pre><code class="language-math">S_m = (2^0h+2^1h+...+2^{m-1}h) - (1*2^0+2*2^1+...+i*2^{i-1})
</code></pre> <p>S<sub>i</sub>的左半部分是等比数列，根据等比数列前m项和，为(2<sup>m</sup>-1)h，右半部分为差比数列，运用错位相减法，可得其前m项和为(m-1)2<sup>m</sup>-1，那么可得总体的前m项和为</p> <pre><code class="language-math">S_m = (2^{m}-1)h-(m-1)2^{m}-1
</code></pre> <p>带入h-1，得到前h-1项和为</p> <pre><code class="language-math">S_{h-1} = n-log_2n-1
</code></pre> <p>可以发现，增长速度最快的是n项，所以在初始化建堆过程中，算法的<strong>时间复杂度为o(n)</strong>。</p> <p>在第二阶段，我们要反复地将大根堆顶部元素输出（与末尾元素交换），并重新建堆。这个过程显然要重复n次，因为堆的高度是h=log<sub>2</sub>n，所以第一次最多要比较的次数为log<sub>2</sub>n次，第二次最多要比较的次数为log<sub>2</sub>n-1次……最后一次只需要比较log<sub>2</sub>1次。所以共需要执行的比较次数最多为</p> <pre><code class="language-math">log_2n +log_2(n-1)+...+log_2(1) = log_2(n!)
</code></pre> <p>因为log<sub>2</sub>n!和nlog<sub>2</sub>n是同阶函数，所以第二步重建堆的<strong>时间复杂度为o(nlog<sub>2</sub>n)</strong>。</p> <p>综合可得，堆排序的<strong>时间复杂度为</strong>o(n)+o(nlog<sub>2</sub>n) = <strong>o(nlog<sub>2</sub>n)</strong></p> <ul> <li> <strong>稳定性</strong>：不稳定。</li> <li> <strong>比较次数</strong>：上述对时间复杂度的分析，可以看出堆排序的比较次数总是o(n)+o(nlog<sub>2</sub>n) = o(nlog<sub>2</sub>n)</li> <li> <strong>代码实现</strong>：</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void HeapSort(vector&lt;int&gt;&amp; nums) {
	int n = nums.size();
	for (int i = n / 2 - 1; i &gt;= 0; i--) {
		//首先从n/2-1这个节点开始，依次向上构建大根堆
		AdjustHeap(nums, n, i);
	}
	//将堆顶元素与末尾元素交换（也就是输出堆顶元素）
	swap(nums[0], nums[n - 1]);
	//默认剩余堆的元素少了一个
	for (int i = n-1; i &gt; 0; i--) {
		//对剩余的堆进行大根堆调整
		AdjustHeap(nums,i,0);
		//输出元素
		swap(nums[0], nums[i-1]);
	}

}
//构建大根堆,n是长度，start是调整位置，自上而下调整
void AdjustHeap(vector&lt;int&gt;&amp; nums, int n, int start) {
	int lc = 2 * start + 1;
	int rc = lc + 1;
	int maxindex = start;
	if (rc &lt; n) {//如果该节点含有两个子节点，选取大的子节点交换
		if (nums[rc] &gt; nums[lc]) {
			maxindex = rc;
		}
		else {
			maxindex = lc;
		}
		if (nums[maxindex] &lt; nums[start]) {
			maxindex = start;
		}
	}
	else if (lc &lt; n) {//如果该节点只含有左儿子，那么比较并交换
		if (nums[lc] &gt; nums[start]) {
			maxindex = lc;
		}
	}
	else {//如果没孩子，那么就不管了
		maxindex = start;
	}
	if (maxindex != start) {
		//交换后，递归地解决被交换孩子节点的子树
		swap(nums[maxindex], nums[start]);
		AdjustHeap(nums, n, maxindex);
	}

}
</code></pre></div></div> <h3 id="归并排序">归并排序</h3> <ul> <li> <strong>过程</strong>：</li> </ul> <ol> <li>先将n个元素看成是n个单元素有序表；</li> <li>通过merge函数将两个有序表之间归并；</li> <li>通过merge函数将再将两个有序表之间归并（因为表内本身有序，所以很快）；</li> <li>一直到只剩一个大的有序表，或者只剩一个元素，单独处理一下。</li> </ol> <ul> <li> <p><strong>适用范围</strong>：顺序表，链表。尤其适用于大量数据的外部排序。</p> </li> <li> <p><strong>性能</strong>：总共n个元素，两两归并，两两再归并，可以形成满二叉树，树的叶子节点共有n个，根据树的性质，共有log<sub>2</sub>n+1层，其中，每一层都要比较n次元素，所以<strong>时间复杂度o(nlog<sub>2</sub>n)</strong>。归并排序中，在merge的过程中，需要一个辅助表来进行临时排序存储，这个表的长度为n，所以 <strong>空间复杂度o(n)</strong>，当然，如果通过旋转等操作，让归并的过程中不使用辅助空间，也可以让归并函数迭代实现的的空间复杂度变为o(1)，但是递归实现的归并排序最少也要o(log<sub>2</sub>n)。</p> </li> <li> <p><strong>稳定性</strong>：稳定。</p> </li> <li> <p><strong>代码实现</strong>：</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void MergeSort(vector&lt;int&gt; &amp;nums) {
	int n = nums.size();
	MergeSortRecursion(nums, 0, n-1);
}
void MergeSortRecursion(vector&lt;int&gt; &amp;nums, int start, int end) {
	//递归地将序列二分
	if (end &lt;= start) {
		return;
	}
	int n = end - start + 1;
	int mid = start + n / 2;
	//对左右序列分别递归地求解问题
	MergeSortRecursion(nums, start,mid - 1);
	MergeSortRecursion(nums, mid, end);
	//左右序列此时都已经有序，然后通过merge函数合并左右序列
	Merge(nums, start, mid - 1, mid, end);
}
void Merge(vector&lt;int&gt; &amp;nums, int s1, int e1, int s2, int e2) {
	vector&lt;int&gt; out;//辅助数组
	int i1 = s1, i2 = s2;
	//拿出左右序列的第一个和第一个比，哪个小就把哪个放在辅助数组，然后继续
	while (i1 &lt;= e1 &amp; i2 &lt;= e2) {
		if (nums[i1] &lt; nums[i2]) {
			out.push_back(nums[i1]);
			i1++;
		}
		else {
			out.push_back(nums[i2]);
			i2++;
		}
	}
	//把剩余一个（肯定是都很大的元素）再依次放进辅助空间
	for (; i1 &lt;= e1; i1++) {
		out.push_back(nums[i1]);
	}
	for (; i2 &lt;= e2; i2++) {
		out.push_back(nums[i2]);
	}
	//把辅助数组的内容再放回原数组
	for (int i = 0,i2 = s1; i &lt;= e2 - s1; i++,i2++) {
		nums[i2] = out[i];
	}
}
</code></pre></div></div> <h2 id="分配式排序桶子排序distribution-sort">分配式排序/桶子排序(Distribution Sort)</h2> <p>上述提到的所有排序方式都是基于比较的排序方式，通过两两元素之间的比较来判断元素应当处在的位置，而分配式排序非比较式的排序，它是通过每个元素内的的部分资讯（关键字），将要排序的元素分配至某些“桶”中。如通过个十百千位关键字的比较，再比如通过日期的年月日关键字的比较，或者姓名中姓的比较等。</p> <p>桶排序是分配式排序的基本原理，基数排序是桶排序在正整数排序中的一个特例应用，计数排序是桶排序在数字最大最小差值小的情况下适用的一个特例。</p> <p>分配式排序都是稳定的。</p> <h3 id="桶排序">桶排序</h3> <ul> <li> <strong>过程</strong>：基本思路是将待排序元素划分到不同的桶。</li> </ul> <ol> <li>先扫描一遍序列求出最大值 maxV 和最小值 minV，然后确定一个桶的个数 k，</li> <li>把区间 [minV, maxV]均匀划分成k个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li> <li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li> <li>将各个桶中的元素合并成一个大的有序序列。</li> </ol> <ul> <li> <strong>适用范围</strong>：序列元素含有多关键字可供比较。</li> <li> <p><strong>性能</strong>：当 k 接近于n时，桶排序的时间复杂度就可以近似认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大（k=n就是计数排序）。</p> </li> <li> <strong>稳定性</strong>：稳定</li> <li>代码实现：</li> </ul> <h3 id="计数排序">计数排序</h3> <ul> <li> <strong>过程</strong>：是一种O(n)的排序算法，但耗费空间较多。</li> </ul> <ol> <li>开一个长度为 max-min+1 的数组。</li> <li>扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。</li> <li>收集。扫描一遍计数器数组，按顺序把值收集起来。</li> </ol> <p>举个例子， nums=[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值，maxValue=5 , minValue=1 ，于是开一个长度为5的计数器数组 counter ，</p> <ol> <li>分配。统计每个元素出现的频率，得到 counter=[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue=1 出现了2次。</li> <li>收集。 counter[0]=2表示1出现了两次，那就向原始数组写入两个1，3。counter[1]=1 表示2出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</li> </ol> <p>计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。</p> <ul> <li> <strong>适用范围</strong>：最大最小值差距不要太大，不然开辟的数组太大占用太多空间。</li> <li> <strong>性能</strong>：</li> </ul> <h3 id="基数排序">基数排序</h3> <ul> <li> <strong>过程</strong>：</li> </ul> <ol> <li>将所有待排序整数（注意，必须是非负整数）统一为位数相同的整数，位数较少的前面补零。一般用10进制，</li> <li>从最低位开始，依次进行一次稳定排序（不稳定的话上一次的结果放到下一次可能就乱了）。这样从最低位一直到最高位排序完成以后，整个序列就变成了一个有序序列。</li> </ol> <p>举个例子，有一个整数序列，0, 123, 45, 386, 106，下面是排序过程：</p> <p>第一次排序，个位，000 123 045 386 106，无任何变化</p> <p>第二次排序，十位，000 106 123 045 386</p> <p>第三次排序，百位，000 045 106 123 386</p> <p>最终结果，0, 45, 106, 123, 386, 排序完成。</p> <ul> <li> <strong>适用范围</strong>：含关键字的正整数排序。</li> </ul> <h2 id="外部排序">外部排序</h2> <h3 id="多路平衡归并">多路平衡归并</h3> <h3 id="置换-选择排序">置换-选择排序</h3> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/deploy-my-server/">配置新的linux服务器并安装iterm2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/llm-fintune/">大模型微调技术梳理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/k8s-pouch/">kubernetes（K8s）+ pouch三主高可用集群部署</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/c-left-right/">C++中左值和右值是什么以及存在的理解误区</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/c-multiple/">C++中&amp;和*的含义</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Haonan Feng. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/george-gca/multi-language-al-folio" rel="external nofollow noopener" target="_blank">multi-language-al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/tabs.min.js?b8748955e1076bbe0dabcf28f2549fdc"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"> <div class="modal-footer" slot="footer"> <span class="help"> <svg version="1.0" class="ninja-examplekey" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1280 1280"> <path d="M1013 376c0 73.4-.4 113.3-1.1 120.2a159.9 159.9 0 0 1-90.2 127.3c-20 9.6-36.7 14-59.2 15.5-7.1.5-121.9.9-255 1h-242l95.5-95.5 95.5-95.5-38.3-38.2-38.2-38.3-160 160c-88 88-160 160.4-160 161 0 .6 72 73 160 161l160 160 38.2-38.3 38.3-38.2-95.5-95.5-95.5-95.5h251.1c252.9 0 259.8-.1 281.4-3.6 72.1-11.8 136.9-54.1 178.5-116.4 8.6-12.9 22.6-40.5 28-55.4 4.4-12 10.7-36.1 13.1-50.6 1.6-9.6 1.8-21 2.1-132.8l.4-122.2H1013v110z"></path> </svg> to select </span> <span class="help"> <svg xmlns="http://www.w3.org/2000/svg" class="ninja-examplekey" viewbox="0 0 24 24"> <path d="M0 0h24v24H0V0z" fill="none"></path> <path d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"></path> </svg> <svg xmlns="http://www.w3.org/2000/svg" class="ninja-examplekey" viewbox="0 0 24 24"> <path d="M0 0h24v24H0V0z" fill="none"></path> <path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"></path> </svg> to navigate </span> <span class="help"> <span class="ninja-examplekey esc">esc</span> to close </span> <span class="help"> <svg xmlns="http://www.w3.org/2000/svg" class="ninja-examplekey backspace" viewbox="0 0 20 20" fill="currentColor"> <path fill-rule="evenodd" d="M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 2.414a1 1 0 00-1.414 1.414L10.586 10l-1.293 1.293a1 1 0 101.414 1.414L12 11.414l1.293 1.293a1 1 0 001.414-1.414L13.414 10l1.293-1.293a1 1 0 00-1.414-1.414L12 8.586l-1.293-1.293z" clip-rule="evenodd"></path> </svg> move to parent </span> </div> </ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation menu",handler:()=>{window.location.href="/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation menu",handler:()=>{window.location.href="/publications/"}},{id:"nav-cv",title:"cv",description:"Ph.D. student in the School of Cyberspace Security, Beijing University of Posts and Telecommunications",section:"Navigation menu",handler:()=>{window.location.href="/cv/"}},{id:"nav-blog",title:"blog",description:"Become a better self",section:"Navigation menu",handler:()=>{window.location.href="/blog/"}},{id:"nav-repositories",title:"repositories",description:"Related open-source projects.",section:"Navigation menu",handler:()=>{window.location.href="/repositories/"}},{id:"nav-news",title:"news",description:"",section:"Navigation menu",handler:()=>{window.location.href="/news/"}},{id:"post-\u914d\u7f6e\u65b0\u7684linux\u670d\u52a1\u5668\u5e76\u5b89\u88c5iterm2",title:"\u914d\u7f6e\u65b0\u7684linux\u670d\u52a1\u5668\u5e76\u5b89\u88c5iterm2",description:"\u670d\u52a1\u5668\u90e8\u7f72",section:"Posts",handler:()=>{window.location.href="/blog/2024/deploy-my-server/"}},{id:"post-\u5927\u6a21\u578b\u5fae\u8c03\u6280\u672f\u68b3\u7406",title:"\u5927\u6a21\u578b\u5fae\u8c03\u6280\u672f\u68b3\u7406",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/llm-fintune/"}},{id:"post-kubernetes-k8s-pouch\u4e09\u4e3b\u9ad8\u53ef\u7528\u96c6\u7fa4\u90e8\u7f72",title:"kubernetes\uff08K8s\uff09+ pouch\u4e09\u4e3b\u9ad8\u53ef\u7528\u96c6\u7fa4\u90e8\u7f72",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/k8s-pouch/"}},{id:"post-c-\u4e2d\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec0\u4e48\u4ee5\u53ca\u5b58\u5728\u7684\u7406\u89e3\u8bef\u533a",title:"C++\u4e2d\u5de6\u503c\u548c\u53f3\u503c\u662f\u4ec0\u4e48\u4ee5\u53ca\u5b58\u5728\u7684\u7406\u89e3\u8bef\u533a",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/c-left-right/"}},{id:"post-c-\u5b9e\u73b0\u4e0d\u540c\u7684\u6392\u5e8f\u7b97\u6cd5-\u4ee5\u53ca\u5b9e\u73b0\u8fc7\u7a0b\u4e2d\u7684\u96be\u70b9",title:"C++\u5b9e\u73b0\u4e0d\u540c\u7684\u6392\u5e8f\u7b97\u6cd5\uff0c\u4ee5\u53ca\u5b9e\u73b0\u8fc7\u7a0b\u4e2d\u7684\u96be\u70b9",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/sort-c/"}},{id:"post-c-\u4e2d-amp-\u548c-\u7684\u542b\u4e49",title:"C++\u4e2d&amp;\u548c*\u7684\u542b\u4e49",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/c-multiple/"}},{id:"post-\u901a\u8fc7\u6700\u5927\u5b50\u5e8f\u548c\u7b97\u6cd5\u9898\u5b66\u4e60\u5206\u6cbb\u6cd5-\u51cf\u6cbb\u6cd5-\u52a8\u6001\u89c4\u5212-\u8d2a\u5fc3\u7b97\u6cd5",title:"\u901a\u8fc7\u6700\u5927\u5b50\u5e8f\u548c\u7b97\u6cd5\u9898\u5b66\u4e60\u5206\u6cbb\u6cd5\u3001\u51cf\u6cbb\u6cd5\u3001\u52a8\u6001\u89c4\u5212\u3001\u8d2a\u5fc3\u7b97\u6cd5",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/Dynamic-Programming/"}},{id:"post-windows\u7cfb\u7edf\u5982\u4f55\u5b89\u88c5proverif-editor",title:"Windows\u7cfb\u7edf\u5982\u4f55\u5b89\u88c5ProVerif Editor",description:"this is what included tabs in a post could look like",section:"Posts",handler:()=>{window.location.href="/blog/2024/ProVerif-editor/"}},{id:"post-a-post-with-images",title:"a post with images",description:"this is what included images could look like",section:"Posts",handler:()=>{window.location.href="/blog/2015/images/"}},{id:"news-the-paper-a-formal-analysis-of-the-fido-uaf-protocol-has-been-accepted-by-ndss-sparkles-smile",title:"The paper \u201cA Formal Analysis of the FIDO UAF Protocol\u201d has been accepted...",description:"",section:"News"},{id:"news-the-paper-fido-gets-verified-a-formal-analysis-of-the-universal-authentication-framework-protocol-has-been-accepted-by-tdsc-sparkles-smile",title:"The paper \u201cFIDO gets verified: A formal analysis of the universal authentication framework...",description:"",section:"News"},{id:"news-ant-group-releases-the-trusted-encrypted-computing-white-paper-https-gw-alipayobjects-com-os-bmw-prod-56176409-5afa-4e86-85f7-1060116c01af-pdf",title:"Ant Group releases the [\u201cTrusted Encrypted Computing White Paper\u201d](https://gw.alipayobjects.com/os/bmw-prod/56176409-5afa-4e86-85f7-1060116c01af.pdf).",description:"",section:"News"},{id:"news-ant-group-launches-a-large-scale-model-encryption-computing-platform-https-databridge-misuan-cloud-alipay-com-portal-allowing-data-to-flow-like-tap-water-reliably-and-freely",title:"Ant Group launches a [large-scale model encryption computing platform](https://databridge-misuan.cloud.alipay.com/portal), allowing data to flow...",description:"",section:"News"},{id:"projects-project-7",title:"project 7",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/7_project/"}},{id:"projects-project-8",title:"project 8",description:"an other project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/8_project/"}},{id:"projects-project-9",title:"project 9",description:"another project with an image \ud83c\udf89",section:"Projects",handler:()=>{window.location.href="/projects/9_project/"}},{id:"projects-project-1",title:"project 1",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"projects-project-2",title:"project 2",description:"a project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/2_project/"}},{id:"projects-project-3-with-very-long-name",title:"project 3 with very long name",description:"a project that redirects to another website",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"projects-project-4",title:"project 4",description:"another without an image",section:"Projects",handler:()=>{window.location.href="/projects/4_project/"}},{id:"projects-project-5",title:"project 5",description:"a project with a background image",section:"Projects",handler:()=>{window.location.href="/projects/5_project/"}},{id:"projects-project-6",title:"project 6",description:"a project with no image",section:"Projects",handler:()=>{window.location.href="/projects/6_project/"}},{id:"socials-email",title:"Send an email",section:"Socials",handler:()=>{window.open("mailto:%66%65%6E%67%68%61%6F%6E%61%6E%32%32%32@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=ruPrB9wAAAAJ","_blank")}},{id:"lang-zh-cn",title:"zh-cn",section:"Languages",handler:()=>{window.location.href="/zh-cn/blog/2024/sort-c/"}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>